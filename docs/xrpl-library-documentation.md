# XRPL ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¬¸ì„œ - TalkTalk í”„ë¡œì íŠ¸

## ê°œìš”

**XRPL (XRP Ledger)** ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” XRP Ledger ë¸”ë¡ì²´ì¸ê³¼ ìƒí˜¸ì‘ìš©í•˜ê¸° ìœ„í•œ JavaScript ë¼ì´ë¸ŒëŸ¬ë¦¬ì…ë‹ˆë‹¤. ì´ í”„ë¡œì íŠ¸ì—ì„œëŠ” **xrpl v3.1.0**ì„ ì‚¬ìš©í•˜ì—¬ ë‹¤ìŒ ì„¸ ê°€ì§€ ì£¼ìš” ê¸°ëŠ¥ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤:

### ğŸ¦ ì§€ê°‘ ê´€ë¦¬ (Wallet Management)
ë””ì§€í„¸ ì§€ê°‘ì„ ë§Œë“¤ê³  ê´€ë¦¬í•˜ëŠ” ê¸°ëŠ¥ì…ë‹ˆë‹¤. ì‹¤ì œ ì§€ê°‘ì²˜ëŸ¼ ëˆ(XRP)ì„ ë³´ê´€í•˜ê³ , ë‹¤ë¥¸ ì‚¬ëŒì—ê²Œ ë³´ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ğŸ’¸ ê±°ë˜ ì „ì†¡ (Transaction)
ì¹œêµ¬ì—ê²Œ ëˆì„ ì†¡ê¸ˆí•˜ëŠ” ê²ƒì²˜ëŸ¼, XRPë‚˜ ë‹¤ë¥¸ ë””ì§€í„¸ í† í°ì„ ë‹¤ë¥¸ ì‚¬ëŒì˜ ì§€ê°‘ìœ¼ë¡œ ë³´ë‚´ëŠ” ê¸°ëŠ¥ì…ë‹ˆë‹¤.

### ğŸ”„ AMM (Automated Market Maker) - ìë™ ê±°ë˜ì†Œ
**ì‰½ê²Œ ë§í•˜ë©´**: 24ì‹œê°„ ìš´ì˜ë˜ëŠ” ìë™ í™˜ì „ì†Œì…ë‹ˆë‹¤!

### ğŸ“¦ Batch Payment - ì¼ê´„ ê²°ì œ
**ì‰½ê²Œ ë§í•˜ë©´**: ì—¬ëŸ¬ ì‚¬ëŒì—ê²Œ í•œ ë²ˆì— ëˆì„ ë³´ë‚´ëŠ” ê¸°ëŠ¥ì…ë‹ˆë‹¤!

**ì‹¤ìƒí™œ ì˜ˆì‹œë¡œ ì´í•´í•˜ê¸°**:
- **ì¼ë°˜ ì†¡ê¸ˆ**: ì¹œêµ¬ 10ëª…ì—ê²Œ ê°ê° ë”°ë¡œ ê³„ì¢Œì´ì²´ â†’ 10ë²ˆ ë°˜ë³µ
- **Batch Payment**: ì¹œêµ¬ 10ëª…ì—ê²Œ í•œ ë²ˆì— ëª¨ë“  ê³„ì¢Œì´ì²´ â†’ 1ë²ˆìœ¼ë¡œ ì™„ë£Œ

**ì–¸ì œ ìœ ìš©í•œê°€ìš”?**
- ğŸ’¼ **ê¸‰ì—¬ ì§€ê¸‰**: ì§ì›ë“¤ì—ê²Œ ì›”ê¸‰ì„ í•œ ë²ˆì— ì§€ê¸‰
- ğŸ **ì„ ë¬¼ ë°°ë¶„**: ì—¬ëŸ¬ ì¹œêµ¬ë“¤ì—ê²Œ ìš©ëˆì„ ë‚˜ëˆ ì„œ ì „ì†¡
- ğŸ’° **ë¶„í•  ê²°ì œ**: ê³µë™êµ¬ë§¤í•œ ê¸ˆì•¡ì„ ì—¬ëŸ¬ ëª…ì´ ë‚˜ëˆ ì„œ ì§€ë¶ˆ
- ğŸ† **ìƒê¸ˆ ë¶„ë°°**: ëŒ€íšŒ ìš°ìŠ¹ìë“¤ì—ê²Œ ìƒê¸ˆì„ í•œ ë²ˆì— ë¶„ë°°
- ğŸ‚ **ë‹¨ì²´ í™˜ê¸‰**: í–‰ì‚¬ ì°¸ê°€ë¹„ í™˜ê¸‰ì„ ì—¬ëŸ¬ ëª…ì—ê²Œ ì¼ê´„ ì²˜ë¦¬

**TalkTalkì—ì„œ ì–´ë–»ê²Œ ì‚¬ìš©í•˜ë‚˜ìš”?**
1. **ì „ì†¡ ë²„íŠ¼ í´ë¦­** â†’ **"ì¼ê´„ ì „ì†¡" ì„ íƒ**
2. **ìˆ˜ì‹ ì ì •ë³´ ì…ë ¥**: ì´ë¦„, ì£¼ì†Œ, ê¸ˆì•¡, ë©”ëª¨
3. **"+ ìˆ˜ì‹ ì ì¶”ê°€"**: í•„ìš”í•œ ë§Œí¼ ìˆ˜ì‹ ì ì¶”ê°€
4. **ì´ ê¸ˆì•¡ í™•ì¸**: ì „ì†¡í•  ì´ ê¸ˆì•¡ê³¼ ìˆ˜ìˆ˜ë£Œ í™•ì¸
5. **ì¼ê´„ ì „ì†¡ ì‹¤í–‰**: ëª¨ë“  ìˆ˜ì‹ ìì—ê²Œ í•œ ë²ˆì— ì „ì†¡
6. **ê²°ê³¼ í™•ì¸**: ê°œë³„ ì „ì†¡ ì„±ê³µ/ì‹¤íŒ¨ ìƒíƒœ í™•ì¸

### ğŸ”’ TokenEscrow - ì¡°ê±´ë¶€ ì§€ë¶ˆ
**ì‰½ê²Œ ë§í•˜ë©´**: "ì¡°ê±´ì´ ë§ìœ¼ë©´ ëˆì„ ë³´ë‚´ì£¼ëŠ”" ì•ˆì „ ë³´ê´€ì†Œì…ë‹ˆë‹¤!

**ì‹¤ìƒí™œ ì˜ˆì‹œë¡œ ì´í•´í•˜ê¸°**:
- **ì¤‘ê³ ê±°ë˜**: íŒë§¤ìê°€ ë¬¼ê±´ì„ ë³´ë‚´ë©´ â†’ êµ¬ë§¤ì ëˆì´ ìë™ìœ¼ë¡œ ì „ë‹¬
- **í”„ë¦¬ëœì„œ**: ì‘ì—…ì´ ì™„ë£Œë˜ë©´ â†’ í´ë¼ì´ì–¸íŠ¸ ëŒ€ê¸ˆì´ ìë™ìœ¼ë¡œ ì§€ê¸‰
- **ì•½ì† ë³´ì¦ê¸ˆ**: ì•½ì†ì„ ì§€í‚¤ë©´ â†’ ë³´ì¦ê¸ˆ ë°˜í™˜, ì•ˆ ì§€í‚¤ë©´ â†’ ìƒëŒ€ë°©ì—ê²Œ ì „ë‹¬
- **ê³„ì•½ê¸ˆ**: ê³„ì•½ ì¡°ê±´ ì¶©ì¡± ì‹œ â†’ ìë™ìœ¼ë¡œ ìƒëŒ€ë°©ì—ê²Œ ì§€ê¸‰
- **ì˜ˆì•½ê¸ˆ**: ì˜ˆì•½ ì·¨ì†Œ ì‹œ â†’ ì¼ì • ë¹„ìœ¨ í™˜ë¶ˆ, ì´ìš© ì™„ë£Œ ì‹œ â†’ ì „ì•¡ ì •ì‚°

**ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?**
1. **ëˆì„ ì•ˆì „ ë³´ê´€ì†Œì— ë„£ê¸°**: "ì´ ì¡°ê±´ì´ ì¶©ì¡±ë˜ë©´ ìƒëŒ€ë°©ì—ê²Œ ë³´ë‚´ì¤˜"
2. **ì¡°ê±´ ëŒ€ê¸°**: ì„¤ì •í•œ ì¡°ê±´ì´ë‚˜ ì‹œê°„ì„ ê¸°ë‹¤ë¦¼
3. **ìë™ ì‹¤í–‰**: ì¡°ê±´ì´ ë§ìœ¼ë©´ ìë™ìœ¼ë¡œ ìƒëŒ€ë°©ì—ê²Œ ì „ì†¡

**TalkTalkì—ì„œ ì–´ë–»ê²Œ ì‚¬ìš©í•˜ë‚˜ìš”?**
1. **ì „ì†¡ ë²„íŠ¼ í´ë¦­** â†’ **"ì¡°ê±´ë¶€ ì†¡ê¸ˆ" ì„ íƒ**
2. **ìˆ˜ì‹ ì ì •ë³´ ì…ë ¥**: ì´ë¦„, ì£¼ì†Œ, ê¸ˆì•¡, ë©”ëª¨
3. **ì¡°ê±´ ì„¤ì •**: ì™„ë£Œ ê°€ëŠ¥ ì‹œê°„, ì·¨ì†Œ ê°€ëŠ¥ ì‹œê°„
4. **ì—ìŠ¤í¬ë¡œ ìƒì„±**: ì¡°ê±´ë¶€ ì§€ë¶ˆ ê³„ì•½ ìƒì„±
5. **ì¡°ê±´ ê´€ë¦¬**:
   - **ì™„ë£Œí•˜ê¸°**: ì¡°ê±´ ì¶©ì¡± ì‹œ ìˆ˜ì‹ ìì—ê²Œ ìë™ ì „ì†¡
   - **ì·¨ì†Œí•˜ê¸°**: ì‹œê°„ ì´ˆê³¼ ì‹œ ì†¡ê¸ˆì¸ì—ê²Œ ìë™ ë°˜í™˜

**ì‹¤ìƒí™œ ì˜ˆì‹œë¡œ ì´í•´í•˜ê¸°**:
- **ì¼ë°˜ í™˜ì „ì†Œ**: ì‚¬ëŒì´ ìš´ì˜í•˜ê³ , ì˜ì—…ì‹œê°„ì´ ìˆê³ , í™˜ì „ ì§ì›ì´ í•„ìš”í•¨
- **AMM ìë™ í™˜ì „ì†Œ**: ì»´í“¨í„°ê°€ 24ì‹œê°„ ìë™ìœ¼ë¡œ ìš´ì˜í•˜ëŠ” í™˜ì „ì†Œ

**ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?**
1. **ê±°ëŒ€í•œ ìˆ˜ì˜ì¥(í’€) ë‘ ê°œê°€ ìˆë‹¤ê³  ìƒê°í•´ë³´ì„¸ìš”**
   - í•œìª½ í’€ì—ëŠ” XRPê°€ ê°€ë“ ğŸŠâ€â™‚ï¸
   - ë‹¤ë¥¸ ìª½ í’€ì—ëŠ” USDê°€ ê°€ë“ ğŸ’µ

2. **í™˜ì „í•˜ê³  ì‹¶ì„ ë•Œ**:
   - XRP 100ê°œë¥¼ í’€ì— ë„£ìœ¼ë©´ â†’ USD 50ê°œë¥¼ ë°›ì•„ê°ˆ ìˆ˜ ìˆìŒ
   - í’€ì˜ ì–‘ì— ë”°ë¼ í™˜ìœ¨ì´ ìë™ìœ¼ë¡œ ì •í•´ì§

3. **ìˆ˜ìˆ˜ë£Œ**: í™˜ì „í•  ë•Œë§ˆë‹¤ ì‘ì€ ìˆ˜ìˆ˜ë£Œ(ë³´í†µ 0.3%)ë¥¼ ì§€ë¶ˆ

**ì™œ ì¢‹ì€ê°€ìš”?**
- â° **24ì‹œê°„ ì–¸ì œë“ ì§€** í™˜ì „ ê°€ëŠ¥
- ğŸ¤– **ì‚¬ëŒ ì—†ì´ ìë™ìœ¼ë¡œ** ì²˜ë¦¬
- ğŸŒ **ì „ ì„¸ê³„ ì–´ë””ì„œë“ ** ì´ìš© ê°€ëŠ¥
- ğŸ’° **ì—¬ëŸ¬ ì¢…ë¥˜ì˜ ë””ì§€í„¸ ëˆ** ì„œë¡œ ë°”ê¿€ ìˆ˜ ìˆìŒ

**ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ**:
"í•œêµ­ì—ì„œ XRPë¥¼ ê°€ì§€ê³  ìˆëŠ”ë°, ë¯¸êµ­ ë‹¬ëŸ¬ê°€ í•„ìš”í•´! â†’ AMMì—ì„œ XRPë¥¼ USDë¡œ ë°”ë¡œ í™˜ì „"

### ì„¤ì¹˜ëœ ë¼ì´ë¸ŒëŸ¬ë¦¬
```json
{
  "xrpl": "^3.1.0"
}
```

## ì£¼ìš” êµ¬ì„±ìš”ì†Œ

### 1. í•µì‹¬ í´ë˜ìŠ¤ ë° ì¸í„°í˜ì´ìŠ¤

#### Client
XRPL ë„¤íŠ¸ì›Œí¬ì— WebSocket ì—°ê²°ì„ ê´€ë¦¬í•˜ëŠ” í´ë˜ìŠ¤
```typescript
import { Client } from 'xrpl';

const client = new Client('wss://s.devnet.rippletest.net:51233');
await client.connect();
```

#### Wallet
XRPL ì§€ê°‘ ìƒì„± ë° ê´€ë¦¬ í´ë˜ìŠ¤
```typescript
import { Wallet } from 'xrpl';

// ìƒˆ ì§€ê°‘ ìƒì„±
const wallet = Wallet.generate();

// ê¸°ì¡´ ì‹œë“œë¡œ ì§€ê°‘ ë³µì›
const wallet = Wallet.fromSeed('sYourSeedHere');
```

#### Transaction Types
ë‹¤ì–‘í•œ ê±°ë˜ ìœ í˜• ì§€ì›
- **Payment**: XRP ë° í† í° ì „ì†¡
- **TrustSet**: í† í° ì‹ ë¢°ì„  ì„¤ì •
- **OfferCreate**: ê±°ë˜ ì£¼ë¬¸ ìƒì„±
- **OfferCancel**: ê±°ë˜ ì£¼ë¬¸ ì·¨ì†Œ
- **AccountSet**: ê³„ì • ì„¤ì • ë³€ê²½
- **EscrowCreate**: ì¡°ê±´ë¶€ ì§€ë¶ˆ ìƒì„± (TokenEscrow)
- **EscrowFinish**: ì¡°ê±´ ì¶©ì¡± ì‹œ Escrow ì™„ë£Œ
- **EscrowCancel**: ì‹œê°„ ì´ˆê³¼ ì‹œ Escrow ì·¨ì†Œ

## í”„ë¡œì íŠ¸ êµ¬ì¡°

### íƒ€ì… ì •ì˜ (`src/types/xrpl.ts`)

```typescript
// XRPL ê³„ì • ì •ë³´
export interface XRPLAccount {
  address: string;
  secret?: string;
  balance: string;
  sequence: number;
  reserve: string;
}

// XRPL í† í° ì •ë³´
export interface XRPLToken {
  currency: string;
  issuer?: string;
  value: string;
  balance?: string;
}

// XRPL ê±°ë˜ ì •ë³´
export interface XRPLTransaction {
  hash: string;
  type: 'Payment' | 'TrustSet' | 'OfferCreate' | 'OfferCancel' | 'AccountSet';
  from: string;
  to?: string;
  amount: string;
  currency: string;
  fee: string;
  timestamp: Date;
  status: 'pending' | 'success' | 'failed';
  metadata?: {
    destinationTag?: number;
    memo?: string;
    invoiceId?: string;
  };
}

// ë„¤íŠ¸ì›Œí¬ ì •ë³´
export interface XRPLNetworkInfo {
  network: 'mainnet' | 'testnet' | 'devnet';
  server: string;
  fee: string;
  reserve: string;
}
```

### ë©”ì¸ í´ë¼ì´ì–¸íŠ¸ (`src/lib/xrpl/xrpl-client.ts`)

#### ë„¤íŠ¸ì›Œí¬ ì„¤ì •
```typescript
class XRPLClient {
  private networkInfo: XRPLNetworkInfo = {
    network: 'devnet',
    server: 'wss://s.devnet.rippletest.net:51233',
    fee: '0.000012',
    reserve: '10',
  };

  setNetwork(network: 'mainnet' | 'testnet' | 'devnet'): void {
    switch (network) {
      case 'mainnet':
        this.networkInfo = {
          network: 'mainnet',
          server: 'wss://xrplcluster.com',
          fee: '0.000012',
          reserve: '10',
        };
        break;
      case 'testnet':
        this.networkInfo = {
          network: 'testnet',
          server: 'wss://s.altnet.rippletest.net:51233',
          fee: '0.000012',
          reserve: '10',
        };
        break;
      case 'devnet':
        this.networkInfo = {
          network: 'devnet',
          server: 'wss://s.devnet.rippletest.net:51233',
          fee: '0.000012',
          reserve: '10',
        };
        break;
    }
  }
}
```

#### ì£¼ìš” ê¸°ëŠ¥

**1. ì—°ê²° ê´€ë¦¬**
```typescript
// ì—°ê²°
async connect(): Promise<boolean> {
  this.client = new Client(this.networkInfo.server);
  await this.client.connect();
  return true;
}

// ì—°ê²° í•´ì œ
async disconnect(): Promise<void> {
  if (this.client) {
    await this.client.disconnect();
    this.client = null;
  }
}
```

**2. ì§€ê°‘ ìƒì„± ë° ê°€ì ¸ì˜¤ê¸°**
```typescript
// ìƒˆ ì§€ê°‘ ìƒì„±
async createWallet(): Promise<XRPLAccount | null> {
  const wallet = Wallet.generate();
  const accountInfo = await this.client.request({
    command: 'account_info',
    account: wallet.address,
  });

  return {
    address: wallet.address,
    secret: wallet.seed,
    balance: accountInfo.result.account_data.Balance || '0',
    sequence: accountInfo.result.account_data.Sequence || 0,
    reserve: this.networkInfo.reserve,
  };
}

// ê¸°ì¡´ ì§€ê°‘ ê°€ì ¸ì˜¤ê¸°
async importWallet(secret: string): Promise<XRPLAccount | null> {
  const wallet = Wallet.fromSeed(secret);
  // ... ê³„ì • ì •ë³´ ì¡°íšŒ ë¡œì§
}
```

**3. XRP ì „ì†¡**
```typescript
async sendXRP(request: XRPLTransferRequest): Promise<XRPLTransaction | null> {
  const payment: Payment = {
    TransactionType: 'Payment',
    Account: this.wallet.address,
    Destination: request.to,
    Amount: request.amount,
    Fee: this.networkInfo.fee,
  };

  // ì„ íƒì  í•„ë“œ ì¶”ê°€
  if (request.destinationTag) {
    payment.DestinationTag = request.destinationTag;
  }

  if (request.memo) {
    payment.Memos = [{
      Memo: {
        MemoData: Buffer.from(request.memo, 'utf8').toString('hex').toUpperCase(),
      },
    }];
  }

  const prepared = await this.client.autofill(payment);
  const signed = this.wallet.sign(prepared);
  const result = await this.client.submitAndWait(signed);

  return {
    hash: result.result.hash,
    type: 'Payment',
    from: this.wallet.address,
    to: request.to,
    amount: request.amount,
    currency: 'XRP',
    fee: this.networkInfo.fee,
    timestamp: new Date(),
    status: result.result.validated ? 'success' : 'failed',
  };
}
```

**4. í† í° ì „ì†¡**
```typescript
async sendToken(
  request: XRPLTransferRequest,
  currency: string,
  issuer: string
): Promise<XRPLTransaction | null> {
  const payment: Payment = {
    TransactionType: 'Payment',
    Account: this.wallet.address,
    Destination: request.to,
    Amount: {
      currency: currency,
      issuer: issuer,
      value: request.amount,
    },
    Fee: this.networkInfo.fee,
  };
  // ... ì‹¤í–‰ ë¡œì§
}
```

### Faucet ê´€ë¦¬ (`src/lib/xrpl/xrpl-faucet.ts`)

í…ŒìŠ¤íŠ¸ë„·ê³¼ ë°ë¸Œë„·ì—ì„œ ë¬´ë£Œ XRPë¥¼ ë°›ê¸° ìœ„í•œ í´ë˜ìŠ¤

```typescript
export class XRPLFaucet {
  private devnetFaucetUrl = 'https://faucet.devnet.rippletest.net/accounts';
  private testnetFaucetUrl = 'https://faucet.altnet.rippletest.net/accounts';

  // ë°ë¸Œë„·ì—ì„œ XRP ìš”ì²­
  async requestDevnetXRP(address: string): Promise<FaucetResult> {
    const response = await fetch(this.devnetFaucetUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        destination: address,
        amount: '1000' // 1000 XRP ìš”ì²­
      })
    });

    const data = await response.json();
    return {
      success: true,
      account: {
        classicAddress: data.account?.classicAddress || address,
        xAddress: data.account?.xAddress || '',
        secret: data.account?.secret || ''
      },
      balance: data.balance || '1000000000' // 1000 XRP in drops
    };
  }

  // ì¼ì¼ ì œí•œ í™•ì¸
  async checkFaucetAvailability(address: string): Promise<{
    available: boolean;
    remainingTime?: number;
    reason?: string;
  }> {
    const lastFaucetTime = localStorage.getItem(`faucet_${address}`);
    if (lastFaucetTime) {
      const timeSinceLastRequest = Date.now() - parseInt(lastFaucetTime);
      const oneDay = 24 * 60 * 60 * 1000;

      if (timeSinceLastRequest < oneDay) {
        return {
          available: false,
          remainingTime: oneDay - timeSinceLastRequest,
          reason: 'ì¼ì¼ í•œë„ ì´ˆê³¼ (24ì‹œê°„ë§ˆë‹¤ 1íšŒë§Œ ê°€ëŠ¥)'
        };
      }
    }
    return { available: true };
  }
}
```

### AMM (Automated Market Maker) (`src/lib/xrpl/xrpl-amm.ts`)

DEX(ë¶„ì‚° ê±°ë˜ì†Œ) ê¸°ëŠ¥ì„ ìœ„í•œ AMM ê´€ë¦¬ í´ë˜ìŠ¤

### Batch Payment & TokenEscrow (`src/lib/xrpl/xrpl-batch.ts`)

í•´ì»¤í†¤ ìš”êµ¬ì‚¬í•­ì„ ì¶©ì¡±í•˜ê¸° ìœ„í•œ **Batch**ì™€ **TokenEscrow** ê¸°ëŠ¥ êµ¬í˜„

#### ğŸ“¦ Batch Payment ê¸°ìˆ  êµ¬í˜„

**í•µì‹¬ í´ë˜ìŠ¤**: `XRPLBatchManager`

**ì£¼ìš” ì¸í„°í˜ì´ìŠ¤**:
```typescript
// ì¼ê´„ ê²°ì œ ì•„ì´í…œ
export interface BatchPaymentItem {
  to: string;           // ë°›ëŠ” ì‚¬ëŒ XRPL ì£¼ì†Œ
  amount: string;       // ì „ì†¡ ê¸ˆì•¡
  currency: string;     // í†µí™” (XRP, USD, EUR, CNY ë“±)
  issuer?: string;      // í† í° ë°œí–‰ì (XRPê°€ ì•„ë‹Œ ê²½ìš° í•„ìˆ˜)
  memo?: string;        // ê±°ë˜ ë©”ëª¨
}

// ì¼ê´„ ê²°ì œ ê²°ê³¼
export interface BatchResult {
  success: boolean;                     // ì „ì²´ ì„±ê³µ ì—¬ë¶€
  results: Array<{                      // ê° ê²°ì œ ê²°ê³¼
    index: number;                      // ê²°ì œ ìˆœì„œ
    success: boolean;                   // ê°œë³„ ì„±ê³µ ì—¬ë¶€
    transactionHash?: string;           // ê±°ë˜ í•´ì‹œ
    error?: string;                     // ì˜¤ë¥˜ ë©”ì‹œì§€
  }>;
  totalSuccessful: number;              // ì„±ê³µí•œ ê²°ì œ ìˆ˜
  totalFailed: number;                  // ì‹¤íŒ¨í•œ ê²°ì œ ìˆ˜
}
```

**í•µì‹¬ ë©”ì„œë“œ**:
```typescript
// ì¼ê´„ ê²°ì œ ì‹¤í–‰
async executeBatchPayments(payments: BatchPaymentItem[]): Promise<BatchResult> {
  const results: BatchResult['results'] = [];
  let successCount = 0;
  let failCount = 0;

  console.log(`ğŸ“¦ Batch Payment ì‹œì‘: ${payments.length}ê°œ ê²°ì œ ì²˜ë¦¬`);

  for (let i = 0; i < payments.length; i++) {
    const payment = payments[i];

    try {
      // Payment íŠ¸ëœì­ì…˜ ìƒì„±
      const paymentTx: Payment = {
        TransactionType: 'Payment',
        Account: this.wallet.address,
        Destination: payment.to,
        Amount: payment.currency.toUpperCase() === 'XRP'
          ? (parseFloat(payment.amount) * 1000000).toString() // XRP to drops
          : {
              currency: payment.currency,
              issuer: payment.issuer || this.getDefaultIssuer(payment.currency),
              value: payment.amount
            }
      };

      // ë©”ëª¨ ì¶”ê°€ (ì„ íƒì‚¬í•­)
      if (payment.memo) {
        paymentTx.Memos = [{
          Memo: {
            MemoData: Buffer.from(`Batch Payment: ${payment.memo}`, 'utf8').toString('hex').toUpperCase()
          }
        }];
      }

      // íŠ¸ëœì­ì…˜ ì‹¤í–‰
      const prepared = await this.client!.autofill(paymentTx);
      const signed = this.wallet.sign(prepared);
      const result = await this.client!.submitAndWait(signed.tx_blob);

      if (result.result.validated) {
        results.push({
          index: i,
          success: true,
          transactionHash: result.result.hash
        });
        successCount++;
      } else {
        throw new Error('íŠ¸ëœì­ì…˜ ê²€ì¦ ì‹¤íŒ¨');
      }

      // ì—°ì† ì „ì†¡ ë¶€í•˜ ë°©ì§€ (1ì´ˆ ëŒ€ê¸°)
      if (i < payments.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }

    } catch (error) {
      results.push({
        index: i,
        success: false,
        error: error instanceof Error ? error.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'
      });
      failCount++;
    }
  }

  return {
    success: successCount > 0,
    results,
    totalSuccessful: successCount,
    totalFailed: failCount
  };
}
```

#### ğŸ”’ TokenEscrow ê¸°ìˆ  êµ¬í˜„

**í•µì‹¬ ì¸í„°í˜ì´ìŠ¤**:
```typescript
// Escrow ìƒì„± íŒŒë¼ë¯¸í„°
export interface EscrowPayment {
  destination: string;      // ìˆ˜ë ¹ì XRPL ì£¼ì†Œ
  amount: string;          // ë³´ê´€í•  ê¸ˆì•¡
  currency: string;        // í†µí™” ì¢…ë¥˜
  issuer?: string;         // í† í° ë°œí–‰ì
  condition?: string;      // í•´ì‹œëœ ì¡°ê±´ (ì˜µì…˜)
  fulfillment?: string;    // ì¡°ê±´ ì¶©ì¡± ì¦ëª… (ì˜µì…˜)
  finishAfter?: number;    // ì™„ë£Œ ê°€ëŠ¥ ì‹œê°„ (Ripple timestamp)
  cancelAfter?: number;    // ì·¨ì†Œ ê°€ëŠ¥ ì‹œê°„ (Ripple timestamp)
  memo?: string;           // ê±°ë˜ ë©”ëª¨
}

// Escrow ê²°ê³¼
export interface EscrowResult {
  success: boolean;                 // ì„±ê³µ ì—¬ë¶€
  escrowSequence?: number;          // Escrow ì‹œí€€ìŠ¤ ë²ˆí˜¸ (ì™„ë£Œ/ì·¨ì†Œ ì‹œ í•„ìš”)
  transactionHash?: string;         // ê±°ë˜ í•´ì‹œ
  error?: string;                   // ì˜¤ë¥˜ ë©”ì‹œì§€
}
```

**í•µì‹¬ ë©”ì„œë“œë“¤**:

**1. Escrow ìƒì„±**:
```typescript
async createEscrow(escrowPayment: EscrowPayment): Promise<EscrowResult> {
  const escrowTx: EscrowCreate = {
    TransactionType: 'EscrowCreate',
    Account: this.wallet.address,
    Destination: escrowPayment.destination,
    Amount: escrowPayment.currency.toUpperCase() === 'XRP'
      ? (parseFloat(escrowPayment.amount) * 1000000).toString()
      : {
          currency: escrowPayment.currency,
          issuer: escrowPayment.issuer || this.getDefaultIssuer(escrowPayment.currency),
          value: escrowPayment.amount
        }
  };

  // ì¡°ê±´ ì„¤ì • (ì˜µì…˜)
  if (escrowPayment.condition) {
    escrowTx.Condition = escrowPayment.condition;
  }

  // ì‹œê°„ ê¸°ë°˜ ì¡°ê±´ ì„¤ì •
  if (escrowPayment.finishAfter) {
    escrowTx.FinishAfter = escrowPayment.finishAfter;
  }

  if (escrowPayment.cancelAfter) {
    escrowTx.CancelAfter = escrowPayment.cancelAfter;
  }

  const prepared = await this.client.autofill(escrowTx);
  const signed = this.wallet.sign(prepared);
  const result = await this.client.submitAndWait(signed.tx_blob);

  if (result.result.validated) {
    return {
      success: true,
      escrowSequence: prepared.Sequence,
      transactionHash: result.result.hash
    };
  } else {
    throw new Error('Escrow íŠ¸ëœì­ì…˜ ê²€ì¦ ì‹¤íŒ¨');
  }
}
```

**2. Escrow ì™„ë£Œ (ì¡°ê±´ ì¶©ì¡± ì‹œ)**:
```typescript
async finishEscrow(
  owner: string,
  escrowSequence: number,
  fulfillment?: string
): Promise<EscrowResult> {
  const finishTx: EscrowFinish = {
    TransactionType: 'EscrowFinish',
    Account: this.wallet.address,
    Owner: owner,
    OfferSequence: escrowSequence
  };

  if (fulfillment) {
    finishTx.Fulfillment = fulfillment;
  }

  const prepared = await this.client.autofill(finishTx);
  const signed = this.wallet.sign(prepared);
  const result = await this.client.submitAndWait(signed.tx_blob);

  return {
    success: result.result.validated,
    transactionHash: result.result.hash
  };
}
```

**3. Escrow ì·¨ì†Œ (ì‹œê°„ ì´ˆê³¼ ì‹œ)**:
```typescript
async cancelEscrow(owner: string, escrowSequence: number): Promise<EscrowResult> {
  const cancelTx: EscrowCancel = {
    TransactionType: 'EscrowCancel',
    Account: this.wallet.address,
    Owner: owner,
    OfferSequence: escrowSequence
  };

  const prepared = await this.client.autofill(cancelTx);
  const signed = this.wallet.sign(prepared);
  const result = await this.client.submitAndWait(signed.tx_blob);

  return {
    success: result.result.validated,
    transactionHash: result.result.hash
  };
}
```

**ì‹œê°„ ë³€í™˜ ìœ í‹¸ë¦¬í‹°**:
```typescript
// JavaScript Date â†’ Ripple Timestamp ë³€í™˜
getRippleTimestamp(date: Date): number {
  // Ripple epochëŠ” 2000ë…„ 1ì›” 1ì¼ 00:00 GMT
  const rippleEpoch = new Date('2000-01-01T00:00:00.000Z').getTime();
  return Math.floor((date.getTime() - rippleEpoch) / 1000);
}

// Ripple Timestamp â†’ JavaScript Date ë³€í™˜
getDateFromRippleTimestamp(timestamp: number): Date {
  const rippleEpoch = new Date('2000-01-01T00:00:00.000Z').getTime();
  return new Date(rippleEpoch + (timestamp * 1000));
}
```

```typescript
export class XRPLAMMManager {
  // ì§€ì› í† í° ì •ì˜ (Devnet)
  private static MOCK_TOKENS = [
    {
      currency: 'USD',
      issuer: 'rJgqyVQrzRQTQREVTYK21843LR7vb7LapX',
      name: 'Devnet USD',
      symbol: 'USD',
      decimals: 2
    },
    {
      currency: 'CNY',
      issuer: 'rKNeAZt7zMLinPBBuopNk6uejPeARgEt5x',
      name: 'Devnet CNY',
      symbol: 'CNY',
      decimals: 2
    },
    // ... ë” ë§ì€ í† í°
  ];

  // Trust Line ìƒì„± (í† í° ìˆ˜ì‹ ì„ ìœ„í•´ í•„ìš”)
  async createTrustLine(
    currency: string,
    issuer: string,
    limit: string = '1000000'
  ): Promise<string | null> {
    const trustSetTx: TrustSet = {
      TransactionType: 'TrustSet',
      Account: this.wallet.address,
      LimitAmount: {
        currency,
        issuer,
        value: limit
      }
    };

    const prepared = await this.client.autofill(trustSetTx);
    const signed = this.wallet.sign(prepared);
    const result = await this.client.submitAndWait(signed.tx_blob);

    return result.result.validated ? result.result.hash : null;
  }

  // AMM í’€ ì •ë³´ ì¡°íšŒ
  async getAMMInfo(
    asset1: { currency: string; issuer?: string },
    asset2: { currency: string; issuer?: string }
  ): Promise<AMMPoolInfo | null> {
    const ammInfoRequest: AMMInfoRequest = {
      command: 'amm_info',
      asset: asset1.currency === 'XRP'
        ? { currency: 'XRP' }
        : { currency: asset1.currency, issuer: asset1.issuer! },
      asset2: asset2.currency === 'XRP'
        ? { currency: 'XRP' }
        : { currency: asset2.currency, issuer: asset2.issuer! }
    };

    const response = await this.client.request(ammInfoRequest);
    return response.result?.amm || null;
  }

  // ìŠ¤ì™‘ ê²¬ì  ê³„ì‚° (Constant Product Formula)
  calculateSwapQuote(
    inputAmount: number,
    poolReserve1: number,
    poolReserve2: number,
    fee: number = 0.003
  ): SwapQuote {
    const inputWithFee = inputAmount * (1 - fee);
    const k = poolReserve1 * poolReserve2;
    const newPoolReserve1 = poolReserve1 + inputWithFee;
    const newPoolReserve2 = k / newPoolReserve1;
    const outputAmount = poolReserve2 - newPoolReserve2;

    return {
      inputAmount: inputAmount.toFixed(6),
      outputAmount: outputAmount.toFixed(6),
      price: (inputAmount / outputAmount).toFixed(6),
      priceImpact: (((newPoolReserve1 / newPoolReserve2) / (poolReserve1 / poolReserve2) - 1) * 100).toFixed(2),
      fee: (inputAmount * fee).toFixed(6),
      slippage: Math.min(((newPoolReserve1 / newPoolReserve2) / (poolReserve1 / poolReserve2) - 1) * 200, 10).toFixed(2)
    };
  }

  // ìŠ¤ì™‘ ì‹¤í–‰
  async executeSwap(
    fromAsset: { currency: string; issuer?: string; amount: string },
    toAsset: { currency: string; issuer?: string; minAmount: string }
  ): Promise<string | null> {
    const payment: Payment = {
      TransactionType: 'Payment',
      Account: this.wallet.address,
      Destination: this.wallet.address, // ìê¸° ìì‹ ì—ê²Œ ì „ì†¡ (ìŠ¤ì™‘)
      Amount: toAsset.currency === 'XRP'
        ? toAsset.minAmount
        : {
            currency: toAsset.currency,
            issuer: toAsset.issuer!,
            value: toAsset.minAmount
          },
      SendMax: fromAsset.currency === 'XRP'
        ? fromAsset.amount
        : {
            currency: fromAsset.currency,
            issuer: fromAsset.issuer!,
            value: fromAsset.amount
          },
      Flags: 0x00020000 // tfPartialPayment
    };

    const prepared = await this.client.autofill(payment);
    const signed = this.wallet.sign(prepared);
    const result = await this.client.submitAndWait(signed.tx_blob);

    return result.result.validated ? result.result.hash : null;
  }
}
```

### ìƒíƒœ ê´€ë¦¬ (Jotai Atoms) (`src/store/xrplAtoms.ts`)

React ìƒíƒœ ê´€ë¦¬ë¥¼ ìœ„í•œ Jotai ì•„í†°ë“¤

```typescript
// ê¸°ë³¸ ìƒíƒœ ì•„í†°
export const xrplAccountAtom = atom<XRPLAccount | null>(null);
export const xrplTokensAtom = atom<XRPLToken[]>([]);
export const xrplTransactionsAtom = atom<XRPLTransaction[]>([]);
export const isXRPLConnectedAtom = atom<boolean>(false);
export const isXRPLLoadingAtom = atom<boolean>(false);
export const xrplErrorAtom = atom<string | null>(null);

// íŒŒìƒ ì•„í†° (ê³„ì‚°ëœ ê°’)
export const xrplBalanceAtom = atom((get) => {
  const account = get(xrplAccountAtom);
  return account?.balance || '0';
});

export const availableBalanceAtom = atom((get) => {
  const account = get(xrplAccountAtom);
  const reserve = get(xrplReserveAtom);

  if (!account) return '0';

  const balance = parseFloat(account.balance);
  const reserveAmount = parseFloat(reserve);

  return Math.max(0, balance - reserveAmount).toString();
});

// ì•¡ì…˜ ì•„í†° (ë¹„ë™ê¸° ì‘ì—…)
export const sendXRPAtom = atom(
  null,
  async (get, set, { to, amount, memo }: {
    to: string;
    amount: string;
    memo?: string;
  }) => {
    set(isXRPLLoadingAtom, true);
    set(xrplErrorAtom, null);

    try {
      // XRP ì „ì†¡ ë¡œì§ ì‹¤í–‰
      const transaction = await xrplClient.sendXRP({ to, amount, memo });

      // ê±°ë˜ ë‚´ì—­ ì—…ë°ì´íŠ¸
      set(xrplTransactionsAtom, [transaction, ...get(xrplTransactionsAtom)]);

      // ì”ì•¡ ì—…ë°ì´íŠ¸
      const account = get(xrplAccountAtom);
      const newBalance = (parseFloat(account.balance) - parseFloat(amount) - 0.000012).toString();
      set(xrplAccountAtom, { ...account, balance: newBalance });

      set(isXRPLLoadingAtom, false);
      return transaction;
    } catch (error) {
      set(xrplErrorAtom, error.message);
      set(isXRPLLoadingAtom, false);
      throw error;
    }
  }
);
```

## ì‚¬ìš© ì˜ˆì‹œ

### 1. ê¸°ë³¸ ì„¤ì •
```typescript
import { xrplClient } from '@/lib/xrpl/xrpl-client';

// ë„¤íŠ¸ì›Œí¬ ì„¤ì •
xrplClient.setNetwork('devnet');

// ì—°ê²°
await xrplClient.connect();
```

### 2. ì§€ê°‘ ìƒì„±
```typescript
// ìƒˆ ì§€ê°‘ ìƒì„±
const newAccount = await xrplClient.createWallet();
console.log('ìƒˆ ì§€ê°‘ ì£¼ì†Œ:', newAccount.address);

// ê¸°ì¡´ ì§€ê°‘ ê°€ì ¸ì˜¤ê¸°
const existingAccount = await xrplClient.importWallet('your-seed-here');
```

### 3. XRP ì „ì†¡
```typescript
const transferRequest = {
  to: 'rDestinationAddress...',
  amount: '1000000', // 1 XRP (ë‹¨ìœ„: drops)
  memo: 'ê±°ë˜ ë©”ëª¨',
  destinationTag: 12345
};

const transaction = await xrplClient.sendXRP(transferRequest);
console.log('ê±°ë˜ í•´ì‹œ:', transaction.hash);
```

### 4. Faucet ì‚¬ìš© (í…ŒìŠ¤íŠ¸ë„·/ë°ë¸Œë„·)
```typescript
import { xrplFaucet } from '@/lib/xrpl/xrpl-faucet';

// ê°€ìš©ì„± í™•ì¸
const availability = await xrplFaucet.checkFaucetAvailability(address);

if (availability.available) {
  // XRP ìš”ì²­
  const result = await xrplFaucet.requestDevnetXRP(address);
  if (result.success) {
    console.log('Faucet XRP ìˆ˜ì‹  ì™„ë£Œ:', result.balance);
  }
}
```

### 5. AMM ìŠ¤ì™‘
```typescript
import { xrplAMM } from '@/lib/xrpl/xrpl-amm';

// Trust Line ìƒì„± (í† í° ìˆ˜ì‹ ìš©)
await xrplAMM.createTrustLine('USD', 'rIssuerAddress...');

// AMM ì •ë³´ ì¡°íšŒ
const ammInfo = await xrplAMM.getAMMInfo(
  { currency: 'XRP' },
  { currency: 'USD', issuer: 'rIssuerAddress...' }
);

// ìŠ¤ì™‘ ê²¬ì  ê³„ì‚°
const quote = xrplAMM.calculateSwapQuote(
  100,      // ì…ë ¥ ê¸ˆì•¡
  10000,    // í’€ ë¦¬ì €ë¸Œ 1
  50000,    // í’€ ë¦¬ì €ë¸Œ 2
  0.003     // ìˆ˜ìˆ˜ë£Œ (0.3%)
);

// ìŠ¤ì™‘ ì‹¤í–‰
const swapResult = await xrplAMM.executeSwap(
  { currency: 'XRP', amount: '100000000' },
  { currency: 'USD', issuer: 'rIssuerAddress...', minAmount: '50' }
);
```

### 6. Batch Payment ì‚¬ìš©
```typescript
import { xrplBatch } from '@/lib/xrpl/xrpl-batch';

// ì§€ê°‘ ì„¤ì •
await xrplBatch.setWallet('sYourPrivateKeyHere...');

// ì¼ê´„ ê²°ì œ ë°ì´í„° ì¤€ë¹„
const payments: BatchPaymentItem[] = [
  {
    to: 'rReceiver1Address...',
    amount: '100',
    currency: 'XRP',
    memo: 'ê¸‰ì—¬ ì§€ê¸‰'
  },
  {
    to: 'rReceiver2Address...',
    amount: '50',
    currency: 'USD',
    issuer: 'rJgqyVQrzRQTQREVTYK21843LR7vb7LapX',
    memo: 'í”„ë¡œì íŠ¸ ë³´ìƒ'
  },
  {
    to: 'rReceiver3Address...',
    amount: '200',
    currency: 'XRP',
    memo: 'ë³´ë„ˆìŠ¤'
  }
];

// ì¼ê´„ ê²°ì œ ì‹¤í–‰
const batchResult = await xrplBatch.executeBatchPayments(payments);

console.log(`ì´ ${payments.length}ê°œ ê²°ì œ ì¤‘:`);
console.log(`âœ… ì„±ê³µ: ${batchResult.totalSuccessful}ê°œ`);
console.log(`âŒ ì‹¤íŒ¨: ${batchResult.totalFailed}ê°œ`);

// ê° ê²°ì œ ê²°ê³¼ í™•ì¸
batchResult.results.forEach((result, index) => {
  if (result.success) {
    console.log(`[${index + 1}] ì„±ê³µ: ${result.transactionHash}`);
  } else {
    console.log(`[${index + 1}] ì‹¤íŒ¨: ${result.error}`);
  }
});
```

### 7. TokenEscrow ì‚¬ìš©
```typescript
import { xrplBatch } from '@/lib/xrpl/xrpl-batch';

// ì§€ê°‘ ì„¤ì •
await xrplBatch.setWallet('sYourPrivateKeyHere...');

// ì‹œê°„ ì„¤ì • (í˜„ì¬ ì‹œê° ê¸°ì¤€)
const now = new Date();
const oneHourLater = new Date(now.getTime() + 3600000);  // 1ì‹œê°„ í›„
const oneDayLater = new Date(now.getTime() + 86400000);  // 24ì‹œê°„ í›„

// Escrow ìƒì„± íŒŒë¼ë¯¸í„°
const escrowPayment: EscrowPayment = {
  destination: 'rDestinationAddress...',
  amount: '500',
  currency: 'XRP',
  finishAfter: xrplBatch.getRippleTimestamp(oneHourLater),    // 1ì‹œê°„ í›„ ì™„ë£Œ ê°€ëŠ¥
  cancelAfter: xrplBatch.getRippleTimestamp(oneDayLater),     // 24ì‹œê°„ í›„ ì·¨ì†Œ ê°€ëŠ¥
  memo: 'í”„ë¡œì íŠ¸ ì™„ë£Œ ì‹œ ì§€ê¸‰'
};

// 1ë‹¨ê³„: Escrow ìƒì„±
console.log('ğŸ”’ Escrow ìƒì„± ì¤‘...');
const createResult = await xrplBatch.createEscrow(escrowPayment);

if (createResult.success) {
  console.log(`âœ… Escrow ìƒì„± ì„±ê³µ!`);
  console.log(`ê±°ë˜ í•´ì‹œ: ${createResult.transactionHash}`);
  console.log(`Escrow ë²ˆí˜¸: ${createResult.escrowSequence}`);

  // 2ë‹¨ê³„: ì¡°ê±´ ì¶©ì¡± í›„ Escrow ì™„ë£Œ (1ì‹œê°„ í›„ ì‹¤í–‰ ê°€ëŠ¥)
  // ì‹¤ì œë¡œëŠ” ì¡°ê±´ì´ ì¶©ì¡±ë˜ì—ˆì„ ë•Œ ì‹¤í–‰
  // setTimeout(async () => {
  //   console.log('ğŸ”“ Escrow ì™„ë£Œ ì‹œë„ ì¤‘...');
  //   const finishResult = await xrplBatch.finishEscrow(
  //     'rOwnerAddress...',
  //     createResult.escrowSequence!
  //   );
  //
  //   if (finishResult.success) {
  //     console.log('âœ… Escrow ì™„ë£Œ! ìê¸ˆì´ ìˆ˜ì‹ ìì—ê²Œ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.');
  //   }
  // }, 3600000); // 1ì‹œê°„ í›„

} else {
  console.log(`âŒ Escrow ìƒì„± ì‹¤íŒ¨: ${createResult.error}`);
}

// 3ë‹¨ê³„: ì‹œê°„ ì´ˆê³¼ ì‹œ Escrow ì·¨ì†Œ (24ì‹œê°„ í›„ ì‹¤í–‰ ê°€ëŠ¥)
// setTimeout(async () => {
//   console.log('ğŸš« Escrow ì·¨ì†Œ ì‹œë„ ì¤‘...');
//   const cancelResult = await xrplBatch.cancelEscrow(
//     'rOwnerAddress...',
//     createResult.escrowSequence!
//   );
//
//   if (cancelResult.success) {
//     console.log('âœ… Escrow ì·¨ì†Œ! ìê¸ˆì´ ì›ì†Œìœ ìì—ê²Œ ë°˜í™˜ë˜ì—ˆìŠµë‹ˆë‹¤.');
//   }
// }, 86400000); // 24ì‹œê°„ í›„

// ì‹œê°„ ë³€í™˜ ìœ í‹¸ë¦¬í‹° ì‚¬ìš© ì˜ˆì‹œ
const futureDate = new Date('2024-12-31T23:59:59Z');
const rippleTime = xrplBatch.getRippleTimestamp(futureDate);
console.log(`ë¯¸ë˜ ì‹œê° (Ripple): ${rippleTime}`);

const backToDate = xrplBatch.getDateFromRippleTimestamp(rippleTime);
console.log(`ë‹¤ì‹œ ë³€í™˜í•œ ë‚ ì§œ: ${backToDate.toISOString()}`);
```

## ë„¤íŠ¸ì›Œí¬ ì •ë³´

### Mainnet
- **ì„œë²„**: `wss://xrplcluster.com`
- **ìš©ë„**: ì‹¤ì œ ê±°ë˜, í”„ë¡œë•ì…˜ í™˜ê²½

### Testnet
- **ì„œë²„**: `wss://s.altnet.rippletest.net:51233`
- **Faucet**: `https://faucet.altnet.rippletest.net/accounts`
- **ìš©ë„**: í†µí•© í…ŒìŠ¤íŠ¸, ìŠ¤í…Œì´ì§• í™˜ê²½

### Devnet
- **ì„œë²„**: `wss://s.devnet.rippletest.net:51233`
- **Faucet**: `https://faucet.devnet.rippletest.net/accounts`
- **ìš©ë„**: ê°œë°œ, ì‹¤í—˜

## ì£¼ìš” íŠ¹ì§•

### 1. ìë™ ì—°ê²° ê´€ë¦¬
- WebSocket ì—°ê²° ìƒíƒœ ìë™ ê°ì§€
- ì¬ì—°ê²° ë¡œì§ ë‚´ì¥
- ì—°ê²° ì‹¤íŒ¨ ì‹œ ì ì ˆí•œ ì—ëŸ¬ ì²˜ë¦¬

### 2. í†µí•© ì—ëŸ¬ ì²˜ë¦¬
- ê³„ì •ì„ ì°¾ì„ ìˆ˜ ì—†ëŠ” ê²½ìš° (ìƒˆ ê³„ì •) ì ì ˆí•œ ì•ˆë‚´
- ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ì‹œ ì¬ì‹œë„ ë¡œì§
- ì‚¬ìš©ì ì¹œí™”ì ì¸ ì—ëŸ¬ ë©”ì‹œì§€

### 3. ì‹±ê¸€í†¤ íŒ¨í„´
```typescript
// ì „ì—­ì—ì„œ í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤ë§Œ ì‚¬ìš©
export const xrplClient = new XRPLClient();
export const xrplFaucet = new XRPLFaucet();
export const xrplAMM = new XRPLAMMManager('devnet');
```

### 4. TypeScript ì™„ì „ ì§€ì›
- ëª¨ë“  ì¸í„°í˜ì´ìŠ¤ì™€ íƒ€ì… ì •ì˜
- ì»´íŒŒì¼ íƒ€ì„ íƒ€ì… ì•ˆì „ì„±
- IntelliSense ì§€ì›

## ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### 1. ê°œì¸í‚¤ ê´€ë¦¬
- ì‹œë“œ/ì‹œí¬ë¦¿ì€ ì•ˆì „í•œ ì €ì¥ì†Œì— ë³´ê´€
- í”„ë¡ íŠ¸ì—”ë“œì—ì„œ í‰ë¬¸ ì €ì¥ ê¸ˆì§€
- í”„ë¡œë•ì…˜ì—ì„œëŠ” í•˜ë“œì›¨ì–´ ì§€ê°‘ ì—°ë™ ê¶Œì¥

### 2. ë„¤íŠ¸ì›Œí¬ ë³´ì•ˆ
- HTTPS/WSS ì—°ê²°ë§Œ ì‚¬ìš©
- ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” XRPL ì„œë²„ì—ë§Œ ì—°ê²°
- Rate limiting ë° ìš”ì²­ ì œí•œ ì ìš©

### 3. ê±°ë˜ ê²€ì¦
- ê±°ë˜ ì „ì†¡ ì „ ê¸ˆì•¡ê³¼ ìˆ˜ìˆ˜ë£Œ ê²€ì¦
- ìˆ˜ì‹  ì£¼ì†Œ í˜•ì‹ ê²€ì¦
- ê±°ë˜ ì™„ë£Œ í›„ ë¸”ë¡ì²´ì¸ì—ì„œ í™•ì¸

## í•´ì»¤í†¤ ìš”êµ¬ì‚¬í•­ ì¶©ì¡± í˜„í™©

### âœ… 1. XRPL ê¸°ë°˜ ê¸°ìˆ  (1ê°œ ì´ìƒ í•„ìˆ˜)
- **Payment**: XRP ë° ë‹¤ì–‘í•œ í† í° ì „ì†¡ ê¸°ëŠ¥ êµ¬í˜„ âœ…
- **Fintech**: ë””ì§€í„¸ ì§€ê°‘ ê´€ë¦¬ ë° ê²°ì œ ì‹œìŠ¤í…œ êµ¬í˜„ âœ…

### âœ… 2. ê¸°ìˆ  ìš”ê±´ (ìµœì†Œ 2ê°œ ì´ìƒ êµ¬í˜„ í•„ìˆ˜)
- **Batch**: ì¼ê´„ ê²°ì œ ì‹œìŠ¤í…œ êµ¬í˜„ âœ…
  - ì—¬ëŸ¬ ìˆ˜ì‹ ìì—ê²Œ í•œ ë²ˆì— ê²°ì œ
  - ê°œë³„ ê²°ì œ ê²°ê³¼ ì¶”ì 
  - ì˜¤ë¥˜ ì²˜ë¦¬ ë° ì¬ì‹œë„ ë¡œì§

- **TokenEscrow**: ì¡°ê±´ë¶€ ì§€ë¶ˆ ì‹œìŠ¤í…œ êµ¬í˜„ âœ…
  - ì‹œê°„ ê¸°ë°˜ ì¡°ê±´ë¶€ ì§€ë¶ˆ
  - Escrow ìƒì„±/ì™„ë£Œ/ì·¨ì†Œ ê¸°ëŠ¥
  - ì•ˆì „í•œ ê±°ë˜ ë³´ì¥

### ğŸ“Š êµ¬í˜„ëœ XRPL ê¸°ìˆ  ìš”ì•½
1. **Payment** - ê¸°ë³¸ ê²°ì œ ì‹œìŠ¤í…œ
2. **AMM** - ìë™ ê±°ë˜ì†Œ (DEX ê¸°ëŠ¥)
3. **Batch** - ì¼ê´„ ê²°ì œ ì‹œìŠ¤í…œ
4. **TokenEscrow** - ì¡°ê±´ë¶€ ì§€ë¶ˆ ì‹œìŠ¤í…œ
5. **ì§€ê°‘ ê´€ë¦¬** - ê³„ì • ìƒì„±/ê°€ì ¸ì˜¤ê¸°/ê´€ë¦¬
6. **Faucet** - í…ŒìŠ¤íŠ¸ë„· XRP ìë™ ì¶©ì „

### ğŸ† í•´ì»¤í†¤ í‰ê°€ í¬ì¸íŠ¸
- **ê¸°ìˆ ì  ì™„ì„±ë„**: ëª¨ë“  ê¸°ëŠ¥ì´ ì‹¤ì œ XRPL ë„¤íŠ¸ì›Œí¬ì—ì„œ ë™ì‘
- **ì‚¬ìš©ì ê²½í—˜**: ì¤‘í•™ìƒë„ ì´í•´í•  ìˆ˜ ìˆëŠ” ì§ê´€ì ì¸ UI/UX
- **ì‹¤ìš©ì„±**: ì‹¤ì œ ì‚¬ìš© ê°€ëŠ¥í•œ ìˆ˜ì¤€ì˜ ê¸°ëŠ¥ êµ¬í˜„
- **í™•ì¥ì„±**: ì¶”ê°€ XRPL ê¸°ëŠ¥ ì—°ë™ ê°€ëŠ¥í•œ êµ¬ì¡°

ì´ ë¬¸ì„œëŠ” TalkTalk í”„ë¡œì íŠ¸ì—ì„œ ì‚¬ìš©í•˜ëŠ” XRPL ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ëª¨ë“  ê¸°ëŠ¥ê³¼ ì‚¬ìš©ë²•ì„ í¬í•¨í•©ë‹ˆë‹¤. í•´ì»¤í†¤ ìš”êµ¬ì‚¬í•­ì„ ëª¨ë‘ ì¶©ì¡±í•˜ë©°, ì‹¤ì œ XRPL ë„¤íŠ¸ì›Œí¬ì—ì„œ ê²€ì¦ëœ ê¸°ëŠ¥ë“¤ë¡œ êµ¬ì„±ë˜ì–´ ìˆìŠµë‹ˆë‹¤.